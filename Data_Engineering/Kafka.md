### Apache Kafka
- 스키마: Json이나 XML보다 Avro를 선호한다. Avro는 원래 하둡을 위해 개발된 직렬화(serialization) 프레임워크다. 데이터를 직렬화하는 형식을 제공하며, 메시지와는 별도>로 스키마를 유지 관리하므로 스키마가 변경되더라도 애플리케이션의 코드를 추가하거나
 변경할 필요가 없다.
- 배치: 카프카는 효율성을 위해 여러 개의 메시지를 모아 batch형태로 파티션에 수록한
다. 이 경우 대기시간(latency)과 처리량(throughput)간의 트레이드오프가 생길 수 있다. 즉, 배치의 크기가 클 수록 단위 시간당 처리될 수 있는 메시지는 많아지지만, 각 메>시지의 전송 시간은 더 길어진다.
- 토픽 == 여러개의 파티션으로 구성 / <b>각 파티션은 서로 다른 서버에 분산될 수 있다.</b> 지금 회사에서도 chriss랑 james에 파티션 분리 돼 있음.
- 파티셔너는 key의 hash값을 생성하고, 그것을 특정 파티션에 대응시킨다.
- 컨슈머 그룹은 하나 이상으 컨슈머로 구성된다. 한 토픽을 소비하기 위해 같은 그룹의 여러 컨슈머가 함께 동작한다. <b>각 컨슈머가 특정 파티션에 대응되는 것을 소유권(ownership)이라고 한다.</b>
- Broker: 시스템 하드웨어 성능에 따라 다르겠지만, 하나의 브로커는 초당 수천 개의 토픽과 수백만 개의 메시지를 처리할 수 있다.
- 디스크 기반의 보존: 토픽별로 보존 옵션을 선택할 수 있다. 보존 기간동안 컨슈머가 동작하지 않더라도 메시지는 카프카에 보존되므로 프로듀서의 메시지 백업이 필요 없다. (카프카 핵심 가이드 11p)
- [Franz Kafka](https://ko.wikipedia.org/wiki/%ED%94%84%EB%9E%80%EC%B8%A0_%EC%B9%B4%ED%94%84%EC%B9%B4) : kafka 이름은 작동방식과 전혀 상관이 없다..?
- Kafka Consumer V0.9 이상부터는 offset 정보를 __consumer_offsets 토픽에 pruduce 한다.
- Burrow
  - [consumer lag monitoring tool](https://blog.voidmainvoid.net/243)
