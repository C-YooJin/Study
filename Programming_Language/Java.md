### Spring
Spring -> Spring legacy Project로 현업에서 아직 많이 쓰이고 있다. </br>
Spring Boot -> 개발 환경 세팅이 좀더 간편하고 (최소화 돼 있고) 실행 및 배포가 간단
해짐. </br>

#### Ref.
- [자바 스프링 home.jsp의 동작 원리](https://all-record.tistory.com/165)

- Spring Bean이란?
  - 스프링 빈이란 자바 객체다. 스프링에서 만들어진 자바 객체가 빈이다. 자바 일반 객체와 차이점은 없고.. 그냥 스프링 컨테이너에서 만들어진 자바 객체가 빈이다.
- DI(Dependency Injection) 의존관계 주입
  - 강한 결합: 객체 내부에서 다른 객체를 생성하는 것은 강한 결합도를 가지는 구조다. A클래스 내부에서 B라는 객체를 생성하고 있다면, B 객체를 C객체로 바꾸고 싶은 경우 A클래스도 수정해줘야 한다.
  - 느슨한 결합: 객체를 주입받는 다는 것은 외부에서 생성된 객체를 인터페이스를 통해서 넘겨받는 것이다. 이렇게 하면 결합도를 낮출 수 있고, 런타임시에 의존관계가 결정되기 때문에 유연한 구조를 가진다. 
- JPA Repository
  - [SpringBoot JPA 예제](https://jdm.kr/blog/121)
- POJO (Plain Old Java Object)
  - pojo란 평범하고 오래 된 자바 객체라는 뜻이다. 왜 이런 이름이 붙었냐면, 사람들이 EJB(Enterprise Java Bean)만 사용하는 걸 보게 된 마틴 파울러라는 사람이 "평범한 자바 객체를 로직에 넣는 게 더 도움 될 때도 있는데, 사람들은 왜 EJB만 쓸까?"에 대한 생각을 하다가, 평범한 자바 객체는 EJB와 같은 이름이 없어서 라는 생각을 하게 됐다. 그래서 POJO라는 이름을 붙여줬다. 
  - 스프링도 pojo 프레임워크중 하나라고 볼 수 있다.
  - 특정 규약에 종속되지 않는 자바 객체
  - 스프링 애플리케이션 = POJO를 이용해서 만든 애플리케이션 로직 + POJO가 어떻게 관계를 맺고 동작하는지 정의해놓은 설계정보
  - ![spring](https://user-images.githubusercontent.com/30011635/87107102-df475400-c299-11ea-850e-4a767b3fac6d.png)
  - EJB 등에서 사용되는 Java Bean 이 아닌 Getter 와 Setter 로 구성된 가장 순수한 형태의 기본 클래스를 POJO라 하며, 이는 Spring에서 고안된 철학의 핵심적인 부분을 구성하는 요소로 사용된다
- thymeleaf
  - 템플릿 엔진이다.
  - HTML, XML, JavaScript, CSS 및 일반 텍스트를 처리 할 수 있는 웹 및 독립형 환경에서 사용할 수 있는 Java 템플릿 엔진
  - 스프링 MVC패턴에서 V(view)를 담당 (꼭 뷰를 만들 때만 쓰는 건 아니다)
  - html 파일을 가져와서 파싱, 분석 후 정해진 위치에 데이터를 치환해서 보여준다.
  - jsp에 비해 속도가 느림
  
## JAVA
- Encoding & Decoding
  - Encoding: 문자, 기호들을 컴퓨터에 저장하거나 통신에 사용할 목적으로 <b>부호화</b> 하는 것이다. 인코더.
  - Decoding: <b>복호화</b> 인코딩 하기 전으로 되돌리는 처리 방식을 말한다. 디코더.
- JAVA 장점
  - 운영체제에 독립적이다. JVM에 의해 돌아가기 때문이다.
  - 객체지향 언어다.
  - 자동으로 메모리 관리해준다. JVM에서 Garbage Collector가 데몬 쓰레드로 돌아간다. 따라서 별도로 메모리 관리 해 줄 필요x
  - 오픈소스다. Oracle JDK와 OPEN JDK가 있는데, 보통 쓰는 건 후자. 오라클 jdk는 유료다.
  - 멀티스레드 구현에 용이하다. 자바는 스레드 생성과 관련된 라이브러리 API를 제공한다.
  - 동적 로딩(Dynamic Loading)을 지원한다.
- JAVA 단점
  - 속도가 비교적 느리다. 자바는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고, JVM에 의해 기계어로 번역되고 실행하는 과정을 거친다. C나 C++은 컴파일링 하면 바로 기계어로 번역되는데, 자바는 JVM 거쳐야돼서 더 느리다는 뜻.
  - 예외처리 불편
- 클래스 vs. 객체
  - 클래스는 '설계도', 객체는 '설계도로 구현한 모든 대상' 의미
- 객체 vs. 인스턴스
  - 클래스 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
  - 객체는 현실세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
  - 객체를 '클래스의 인스턴스' 라고 부르기도 함
  - '방금 인스턴스화하여 레퍼런스를 할당한' 객체를 인스턴스라고 말하지만, 이는 원본(추상적인 개념)으로 부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.
- Overloading vs. Overriding
  - overloading(오버로딩): 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우
  - overriding(오버라이딩):  상위 클래스의 메서드와 이름과 용례(signature)가 같은 함수를 하위 클래스에 재정의하는 것 / 상속 관계에 있는 클래스 간에 같은 이름의 메서드를 정의
- Call by Reference vs. Call by Value
  - Call by Value (값에 의한 호출)
    - 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.
    - 함수 호출시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.
    - 복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다.
    - 따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.
  - Call by Reference (참조에 의한 호출)
    - 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.
    - 함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가르킨다.)
    - 따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.
