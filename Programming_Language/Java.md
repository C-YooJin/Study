## JAVA
- Encoding & Decoding
  - Encoding: 문자, 기호들을 컴퓨터에 저장하거나 통신에 사용할 목적으로 <b>부호화</b> 하는 것이다. 인코더.
  - Decoding: <b>복호화</b> 인코딩 하기 전으로 되돌리는 처리 방식을 말한다. 디코더.
- JAVA 장점
  - 운영체제에 독립적이다. JVM에 의해 돌아가기 때문이다.
  - 객체지향 언어다.
  - 자동으로 메모리 관리해준다. JVM에서 Garbage Collector가 데몬 쓰레드로 돌아간다. 따라서 별도로 메모리 관리 해 줄 필요x
  - 오픈소스다. Oracle JDK와 OPEN JDK가 있는데, 보통 쓰는 건 후자. 오라클 jdk는 유료다.
  - 멀티스레드 구현에 용이하다. 자바는 스레드 생성과 관련된 라이브러리 API를 제공한다.
  - 동적 로딩(Dynamic Loading)을 지원한다.
- JAVA 단점
  - 속도가 비교적 느리다. 자바는 한 번의 컴파일링으로 실행 가능한 기계어가 만들어지지 않고, JVM에 의해 기계어로 번역되고 실행하는 과정을 거친다. C나 C++은 컴파일링 하면 바로 기계어로 번역되는데, 자바는 JVM 거쳐야돼서 더 느리다는 뜻.
  - 예외처리 불편
- 클래스 vs. 객체
  - 클래스는 '설계도', 객체는 '설계도로 구현한 모든 대상' 의미
- 객체 vs. 인스턴스
  - 클래스 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 부른다.
  - 객체는 현실세계에 가깝고, 인스턴스는 소프트웨어 세계에 가깝다.
  - 객체를 '클래스의 인스턴스' 라고 부르기도 함
  - '방금 인스턴스화하여 레퍼런스를 할당한' 객체를 인스턴스라고 말하지만, 이는 원본(추상적인 개념)으로 부터 생성되었다는 것에 의미를 부여하는 것일 뿐 엄격하게 객체와 인스턴스를 나누긴 어렵다.
- Overloading vs. Overriding
  - overloading(오버로딩): 두 메서드가 같은 이름을 갖고 있으나 인자의 수나 자료형이 다른 경우
  - overriding(오버라이딩):  상위 클래스의 메서드와 이름과 용례(signature)가 같은 함수를 하위 클래스에 재정의하는 것 / 상속 관계에 있는 클래스 간에 같은 이름의 메서드를 정의
- Call by Reference vs. Call by Value
  - Call by Value (값에 의한 호출)
    - 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.
    - 함수 호출시 인자로 전달되는 변수의 값을 복사하여 함수의 인자로 전달한다.
    - 복사된 인자는 함수 안에서 지역적으로 사용되는 local value의 특성을 가진다.
    - 따라서 함수 안에서 인자의 값이 변경되어도, 외부의 변수의 값은 변경되지 않는다.
  - Call by Reference (참조에 의한 호출)
    - 함수가 호출될 때, 메모리 공간 안에서는 함수를 위한 별도의 임시 공간이 생성된다.
    - 함수 호출시 인자로 전달되는 변수의 레퍼런스를 전달한다. (해당 변수를 가르킨다.)
    - 따라서 함수 안에서 인자의 값이 변경되면, 인자로 전달된 변수의 값도 함께 변경된다.
    
 ### Jackson 라이브러리
 java object를 JSON으로 변환하거나 JSON을 java object로 변환하는 데 사용하는 java 라이브러리
 
 ### HikariCp
 - Database와 Connection Pool을 관리해준다.
 - 실제로 JDBC 커넥션을 맺는 과정은 상당히 복잡하고 자원을 많이 소모한다. 부하도 심하고.. -> hikaricp를 사용하면 미리 정해놓은 만큼에 커넥션을 pool에 담아두고, 요청이 들어오면 Thread가 커넥션을 요청하고, Hikari는 pool내에 있는 커넥션을 연결해준다. 그러면 Thread입장에서는 바로 쿼리를 날릴 수 있게 된다. 
- 일단 뭔가 JDBC 사용할 때 복잡&부하 큰 문제 해결하기 위해 있는 것이라고 알아두기.

### slf4j
- 자바의 로깅 관련 모듈.

### `private volatile string test = test;`
- Ref. [Java volatile이란?](https://nesoy.github.io/articles/2018-06/Java-volatile)
- java volatile 키워드는 java 변수를 Main Memory에 저장하겠다고 명시하는 것이다.
- 변수를 read 할 때, CPU cache에 저장 된 값이 아닌 Main Memory에서 읽는 것이다.
- write 할 때도 마찬가지로 Main Memory에 작성한다. 
#### 어떨 때 쓸까?
- Multi Thread환경에서 Thread가 변수 값을 읽어올 때 각각의 CPU cache에 저장된 값이 다르기 때문에 <b>변수 값 불일치</b>가 일어난다. 예를 들어, a라는 변수에 대해 한 쓰레드에서는 값을 읽고 더하고, 한 쓰레드에 대해서는 a를 읽기만 할 때 문제가 발생한다. 앞 쓰레드에서는 a값의 변형이 일어나지만(cache메모리로 가져와서 작업한다), 뒷 쓰레드는 변형되기 전(Main Memory에 있는) a값을 가져오기 때문이다. 이런 경우 변수 a에 대해 Main Memory에서 직접 read & write 한다면 문제 없다. 
- `volatile`이 가장 적합한 상황: 멀티쓰레드 환경에서 한 쓰레드는 read & write 하고, 나머지는 read만 하는 경우
- 여러 쓰레드에서 write를 하는 경우에는 적합하지 않다. 연산 후 main memory에 반영되기 전 다른 쓰레드에서 read 하고 write 해버린다면 값의 오차가 생긴다. 자세한 건 위 ref 블로그 참고.

### enum 열거형 (JDK 1.5 up)
- 클래스처럼 보이게 하는 상수
- 서로 관련 있는 상수들을 모아 심볼릭한 명칭의 집합
- Enum클래스형을 기반으로 한 클래스형 선언
```
<EnumExample.java>
public emun Example {
  WALKING, RUNNING, TAEKONDO
}
```
- 값들은 대문자로 적어준다.

